var ctor = (function() {  // generated by build.sh for running on Node.js
// Generated by CoffeeScript 1.7.1
var KiiAnalyticsRequest, root, _KiiAnalytics;

root = ((typeof exports) !== "undefined") && (exports !== null) ? new Object() : this;

root.KiiAnalyticsSite = {
  US: "https://api.kii.com/api",
  JP: "https://api-jp.kii.com/api",
  CN: "https://api-cn2.kii.com/api",
  SG: "https://api-sg.kii.com/api"
};


/**
    @class The main SDK class
    @exports root.KiiAnalytics as KiiAnalytics
    
    This class must be initialized before any KiiAnalytics SDK functions are performed. This class also allows the application to make some high-level user calls and access some application-wide data at any time using static methods.
 */

root.KiiAnalytics = (function() {
  var _instance;

  function KiiAnalytics() {}

  _instance = null;

  KiiAnalytics.getBaseURL = function() {
    return _instance._baseURL;
  };


  /**
      Set a custom API endpoint URL
      @param String url A string containing the desired endpoint
   */

  KiiAnalytics.setBaseURL = function(url) {
    root.KiiAnalytics.logger("Setting base URL: " + url);
    return _instance._baseURL = url;
  };


  /**
      Retrieve the current app ID
      @returns {String} The current app ID
   */

  KiiAnalytics.getAppID = function() {
    return _instance._appID;
  };


  /**
      Retrieve the current app key
      @returns {String} The current app key
   */

  KiiAnalytics.getAppKey = function() {
    return _instance._appKey;
  };


  /**
      Kii Analytics SDK Version Number
      @returns {String} current version number of the SDK
   */

  KiiAnalytics.getSDKVersion = function() {
    return "2.1.5";
  };

  KiiAnalytics.getAppKey = function() {
    return _instance._appKey;
  };


  /**
      Get the deviceId. If deviceId has not specified while initialization, it returns SDK generated deviceId.It is recommended to retrieve the deviceId and store it to identify the device properly. 
      @returns {String} deviceId.
   */

  KiiAnalytics.getDeviceId = function() {
    return _instance._deviceId;
  };


  /**
      Is the SDK printing logs to the console?
      @returns {Boolean} True if printing logs, false otherwise
   */

  KiiAnalytics.isLogging = function() {
    return _instance._logging;
  };


  /**
      Set the logging status of the SDK
      
      Helpful for development - we strongly advice you turn off logging for any production code.
      @param Boolean True if logs should be printed, false otherwise
      @example
      KiiAnalytics.setLogging(true);
   */

  KiiAnalytics.setLogging = function(logging) {
    root.KiiAnalytics.logger("Setting logging: " + logging);
    return _instance._logging = logging;
  };


  /** Initialize the Kii SDK with a specific URL
  
  Should be the first Kii SDK action your application makes
  @param String appID The application ID found in your Kii developer console
  @param String appKey The application key found in your Kii developer console
  @param KiiAnalyticsSite site Can be one of the constants KiiAnalyticsSite.US, KiiAnalyticsSite.JP, KiiAnalyticsSite.CN or KiiAnalyticsSite.SG depending on your location.
  @param deviceid If deviceId is not provided, SDK generates a new deviceId and use it when upload events.deviceId can be retrieved by {@link KiiAnalytics.getDeviceId()}.It is recommended to retrieve the deviceId and store it to identify the device properly. 
  @example
  // initialize without deviceId
  Kii.initializeWithSite("my-app-id", "my-app-key", KiiAnalyticsSite.JP);
  // initialize with deviceId
  Kii.initializeWithSite("my-app-id", "my-app-key", KiiAnalyticsSite.JP, "my-device-id");
   */

  KiiAnalytics.initializeWithSite = function(appID, appKey, site, deviceId) {
    _instance = new _KiiAnalytics(appID, appKey, site, deviceId);
    if ((deviceId != null ? deviceId.length : void 0) > 0 && _instance._deviceId !== deviceId) {
      _instance._deviceId = deviceId;
    }
    return root.KiiAnalytics.logger("Initialized " + appID + ", " + appKey + ", " + site);
  };


  /** Initialize the KiiAnalytics SDK
  
  Should be the first KiiAnalytics SDK action your application makes
  @param String appID The application ID found in your Kii developer console
  @param String appKey The application key found in your Kii developer console
  @param deviceid If deviceId is not provided, SDK generates a new deviceId and use it when upload events. deviceId can be retrieved by {@link KiiAnalytics.getDeviceId()}.It is recommended to retrieve the deviceId and store it to identify the device properly. 
  @example
  // initialize without deviceId
  Kii.initializeWithSite("my-app-id", "my-app-key", KiiAnalyticsSite.JP);
  // initialize with deviceId
  Kii.initializeWithSite("my-app-id", "my-app-key", KiiAnalyticsSite.JP, "my-device-id");
   */

  KiiAnalytics.initialize = function(appID, appKey, deviceId) {
    return root.KiiAnalytics.initializeWithSite(appID, appKey, root.KiiAnalyticsSite.US, deviceId);
  };

  KiiAnalytics.error = function(message) {
    return console.log("KiiAnalytics SDK Error => " + message);
  };


  /** 
      Utilize the KiiAnalytics logger to track SDK-specific actions
      
      Helpful for development - we strongly advice you turn off logging for any production code.
      @param String message The message to print to console.log in your browser
      @example
      KiiAnalytics.logger("My message");
   */

  KiiAnalytics.logger = function(message) {
    if (_instance._logging) {
      return console.log("KiiAnalytics => " + message);
    }
  };


  /** Log a single event to be uploaded to KiiAnalytics
  
  Use this method if you'd like to track an event by name only. If you'd like to track other attributes/dimensions, please use KiiAnalytics.trackEventWithExtras(eventName, parameters)
  
  Will return TRUE every time unless there was an error writing to the cache.
  @param {String} eventName A string representing the event name for later tracking
  @return {Boolean} TRUE if the event was added properly, FALSE otherwise
   */

  KiiAnalytics.trackEvent = function(eventName) {
    return root.KiiAnalytics.trackEventWithExtras(eventName, null);
  };


  /** Log a single event to be uploaded to KiiAnalytics
  
  Use this method if you'd like to track an event by name and add extra information to the event.
  Will return TRUE every time unless there was an error writing to the cache OR if one of the extra key/value pairs was not JSON-encodable.
  @param {String} eventName A string representing the event name for later tracking
  @param {Object} extras A dictionary of JSON-encodable key/value pairs to be attached to the event.
  Key must follow the pattern "^[a-zA-Z][a-zA-Z0-9_]{0,63}$".Supported value type is string, number, boolean and array.
  Empty string or empty array will be considered as invalid.Type of array elements must be string, number or boolean.
  If any key/value pair is invalid, it will be ignored and not sent to the KiiCloud.
  @return {Boolean} TRUE if the event was added properly, FALSE otherwise
   */

  KiiAnalytics.trackEventWithExtras = function(eventName, extras) {
    return root.KiiAnalytics.trackEventWithExtrasAndCallbacks(eventName, extras, null);
  };


  /** Log a single event to be uploaded to KiiAnalytics
  
  Use this method if you'd like to track an event asynchronously by name and add extra information to the event.
  
  @param {String} eventName A string representing the event name for later tracking
  @param {Object} extras A dictionary of JSON-encodable key/value pairs to be attached to the event.
  Key must follow the pattern "^[a-zA-Z][a-zA-Z0-9_]{0,63}$".Supported value type is string, number, boolean and array.
  Empty string or empty array will be considered as invalid.Type of array elements must be string, number or boolean.
  If any key/value pair is invalid, it will be ignored and not sent to the KiiCloud.
  @param {Object} callbacks An object with callback methods defined
  @param {Method} callbacks.success The callback method to call on a successful log request
  @param {Method} callbacks.failure The callback method to call on a failed log request
   */

  KiiAnalytics.trackEventWithExtrasAndCallbacks = function(eventName, extras, callbacks) {
    var isValidArrayContents, isValidKey, isValidValue, key, keyPattern, now, payload, request, trackingCallbacks, value;
    now = Math.round((new Date()).getTime());
    keyPattern = '^[a-zA-Z][a-zA-Z0-9_]{0,63}$';
    root.KiiAnalytics.logger("deviceId = " + _instance._deviceId);
    payload = {
      _triggeredAt: now,
      _uploadedAt: now,
      _deviceID: _instance._deviceId,
      _type: eventName
    };
    isValidKey = function(key) {
      return (key != null) && (key.match(keyPattern) != null);
    };
    isValidArrayContents = function(array) {
      var type, val, _i, _len;
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        val = array[_i];
        type = typeof val;
        if (type !== 'string' && type !== 'boolean' && type !== 'number') {
          return false;
        }
        if (type === 'string') {
          if (val.length <= 0) {
            return false;
          }
        } else if (type === 'number') {
          if (!((isFinite(val)) && (!isNaN(val)))) {
            return false;
          }
        }
      }
      return true;
    };
    isValidValue = function(value) {
      var type;
      type = typeof value;
      if (type === 'string') {
        return value.length > 0;
      } else if (type === 'number') {
        return (isFinite(value)) && (!isNaN(value));
      } else if (type === 'object') {
        return value instanceof Array && value.length > 0 && isValidArrayContents(value);
      } else if (type === 'boolean') {
        return true;
      } else {
        return false;
      }
    };
    for (key in extras) {
      value = extras[key];
      if (isValidKey(key) && isValidValue(value)) {
        payload[key] = value;
      } else {
        root.KiiAnalytics.logger("ignoring invalid key/value pair, key:" + key + " value:" + value);
      }
    }
    request = new KiiAnalyticsRequest("/event");
    request.data = payload;
    request.method = "POST";
    request.anonymous = true;
    request.contentType = "application/vnd.kii.Event+json";
    trackingCallbacks = {
      success: function(data) {
        if (callbacks != null) {
          return callbacks.success();
        }
      },
      failure: function(error, statusCode) {
        if (callbacks != null) {
          return callbacks.failure(error, statusCode);
        }
      }
    };
    return request.execute(trackingCallbacks, false);
  };

  return KiiAnalytics;

})();

_KiiAnalytics = (function() {
  function _KiiAnalytics(appID, appKey, site, deviceId) {
    if (site == null) {
      site = root.KiiAnalyticsSite.US;
    }
    if (deviceId == null) {
      deviceId = _KiiAnalytics.generateDeviceId();
    }
    this._appKey = appKey;
    this._appID = appID;
    this._baseURL = site;
    this._deviceId = deviceId;
  }

  _KiiAnalytics.generateDeviceId = function() {
    var _p8;
    _p8 = function(s) {
      var p;
      p = (Math.random().toString(16) + "000000000").substr(2, 8);
      if (s) {
        return "-" + p.substr(0, 4) + "-" + p.substr(4, 4);
      } else {
        return p;
      }
    };
    return _p8() + _p8(true) + _p8(true) + _p8();
  };

  return _KiiAnalytics;

})();

KiiAnalyticsRequest = (function() {
  KiiAnalyticsRequest._disableCacheURL = function(url) {
    if (url.indexOf('?') !== -1) {
      url += "&disable_cache=";
    } else {
      url += "?disable_cache=";
    }
    url += new Date().getTime();
    return url;
  };

  function KiiAnalyticsRequest(path) {
    this.path = "/apps/" + (root.KiiAnalytics.getAppID()) + path;
    this.path = KiiAnalyticsRequest._disableCacheURL(this.path);
    this.method = "GET";
    this.headers = {
      "user-agent": "js/1.0",
      "accept": "*/*"
    };
    this.data = null;
    this.contentType = "application/json";
    this.anonymous = false;
    this.accept = null;
    this.success = function() {};
    this.failure = function() {};
  }

  KiiAnalyticsRequest.prototype.execute = function(callbacks, ignoreBody) {
    var ajaxData, json_text, url;
    if (callbacks != null) {
      this.success = callbacks.success != null ? callbacks.success : this.success;
      this.failure = callbacks.failure != null ? callbacks.failure : this.failure;
    }
    url = root.KiiAnalytics.getBaseURL() + this.path;
    json_text = JSON.stringify(this.data);
    root.KiiAnalytics.logger("Making request[" + this.method + "] to " + url + " with path: " + this.path + " and data: " + json_text);
    this.headers['x-kii-appid'] = root.KiiAnalytics.getAppID();
    this.headers['x-kii-appkey'] = root.KiiAnalytics.getAppKey();
    this.headers['x-kii-sdk'] = root.KiiSDKClientInfo.getSDKClientInfo();
    if (this.accept != null) {
      this.headers['accept'] = this.accept;
    }
    this.headers['x-kii-path'] = this.path;
    if (!this.anonymous) {
      this.headers['Authorization'] = "Bearer " + (root.KiiAnalytics.getAccessToken());
    }
    ajaxData = {
      type: this.method,
      url: url,
      dataType: "json",
      headers: this.headers,
      contentType: this.contentType,
      complete: (function(_this) {
        return function(xhr, status) {
          var data, errString, error, numstatus, suc;
          root.KiiAnalytics.logger("Completed Request[" + xhr.status + "]");
          root.KiiAnalytics.logger(xhr.responseText);
          numstatus = parseInt(xhr.status, 10);
          suc = 200 <= numstatus && numstatus < 400;
          data = null;
          if (!ignoreBody) {
            try {
              data = jQuery.parseJSON(xhr.responseText);
            } catch (_error) {
              error = _error;
              data = null;
            }
          }
          if (suc) {
            return _this.success(data, xhr.status);
          } else {
            errString = null;
            if (data != null) {
              if (data.errorCode != null) {
                errString = data.errorCode;
                if (data.message != null) {
                  errString += ": " + data.message;
                }
              }
            }
            return _this.failure(errString, xhr.status);
          }
        };
      })(this)
    };
    if (json_text != null) {
      ajaxData.headers['content-length'] = json_text.length;
      ajaxData.data = json_text;
      ajaxData.processData = false;
    }
    return $.ajax(ajaxData);
  };

  return KiiAnalyticsRequest;

})();

root.KiiSDKClientInfo = (function() {
  var _clientInfo;

  function KiiSDKClientInfo() {}

  _clientInfo = null;

  KiiSDKClientInfo.getSDKClientInfo = function() {
    if (KiiSDKClientInfo._clientInfo == null) {
      KiiSDKClientInfo._clientInfo = "sn=jsa;sv=" + root.KiiAnalytics.getSDKVersion();
    }
    return KiiSDKClientInfo._clientInfo;
  };

  return KiiSDKClientInfo;

})();

return root;
});  // generated by build.sh for running on Node.js

(function() {
// Following code was generated by build.sh for running on Node.js
var b = ((typeof module) !== "undefined") && (module !== null);
if (b && module.exports) {
  module.exports = {
    create: function() {
      return ctor.call(this);
    }
  };
} else {
  ctor();
}
})();
